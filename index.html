<!DOCTYPE html>
<html>
  <head>
    <base href="/" />

    <meta charset="UTF-8" />
    <meta content="IE=Edge" http-equiv="X-UA-Compatible" />
    <meta name="description" content="A new Flutter project." />

    <!-- iOS meta tags & icons -->
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black" />
    <meta name="apple-mobile-web-app-title" content="jeenew_logging" />
    <link rel="apple-touch-icon" href="icons/Icon-192.png" />

    <!-- Favicon -->
    <link rel="icon" type="image/png" href="favicon.png" />

    <title></title>
    <link rel="manifest" href="manifest.json" />

    <!-- Thay th·∫ø CDN b·∫±ng file local -->
    <script src="js/face-api.min.js"></script>
    <script src="js/js_library.js"></script>
    <!-- <script src="js/face_register.js"></script> -->

    <script>
      async function loadFaceModels() {
        try {
          await faceapi.nets.ssdMobilenetv1.loadFromUri("models");
          await faceapi.nets.faceLandmark68Net.loadFromUri("models");
          await faceapi.nets.faceRecognitionNet.loadFromUri("models");
          await faceapi.nets.faceExpressionNet.loadFromUri("models");
          await faceapi.nets.tinyFaceDetector.loadFromUri("models");
          console.log("‚úÖ Face-api models loaded");
        } catch (err) {
          console.error("‚ùå L·ªói load models:", err);
          return;
        }
      }
      console.log("Loading model from", "/models");

      async function detectFaceFromBase64(base64Image) {
        const img = new Image();
        img.src = base64Image;

        return new Promise((resolve) => {
          img.onload = async () => {
            const canvas = document.createElement("canvas");
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(img, 0, 0);

            const detections = await faceapi
              .detectAllFaces(canvas)
              .withFaceLandmarks()
              .withFaceDescriptors()
              .withFaceExpressions();
            let result = {
              faceCount: 0,
              isSmiling: false,
              // isEyesClosed: false,
              isTurnLeft: false,
              isTurnRight: false,
            };

            if (detections.length > 0) {
              result.faceCount = detections.length;

              const detection = detections[0];
              const expressions = detection.expressions;
              result.isSmiling = expressions.happy > 0.7;
              const landmarks = detection.landmarks;

              // const leftEye = landmarks.getLeftEye();
              // const rightEye = landmarks.getRightEye();

              // const leftEyeOpen = leftEye[4].y - leftEye[1].y > 2;
              // const rightEyeOpen = rightEye[4].y - rightEye[1].y > 2;
              // result.isEyesClosed = !leftEyeOpen && !rightEyeOpen;

              const nose = landmarks.getNose();
              const noseX = nose[3].x;
              const midX = canvas.width / 2;

              if (noseX < midX - 30) result.isTurnLeft = true;
              if (noseX > midX + 30) result.isTurnRight = true;
            }

            resolve(result);
          };
        });
      }

      // ======== ƒêƒÇNG K√ù KHU√îN M·∫∂T =======
      let faceRegisterController = null;

      class FaceRegisterController {
        constructor(containerId = "faceRegisterContainer") {
          this.container = document.getElementById(containerId);
          this.video = null;
          this.stream = null;
          this.recorder = null;
          this.chunks = [];
          this.detectLoopId = null;
          this.stopTimeout = null;
          this.guideCanvas = null;
          this.guideCtx = null;
          this.currentStep = 0;
          this.steps = ["center", "left", "right", "up", "down"];
          this.stableCount = 0;
          this.requiredStableFrames = 5;
          this.completeCalled = false;
        }

        // ---- helper ƒë·ªÉ c·∫≠p nh·∫≠t k√≠ch th∆∞·ªõc canvas v√† context scaling ----
        updateCanvasSize() {
          if (!this.video || !this.guideCanvas) return;
          // k√≠ch th∆∞·ªõc hi·ªÉn th·ªã (CSS pixels)
          const vw = this.video.clientWidth || this.video.offsetWidth;
          const vh = this.video.clientHeight || this.video.offsetHeight;
          const ratio = window.devicePixelRatio || 1;

          // internal pixel buffer = CSS pixels * DPR
          this.guideCanvas.width = Math.round(vw * ratio);
          this.guideCanvas.height = Math.round(vh * ratio);

          // CSS size c·ªßa canvas = k√≠ch th∆∞·ªõc hi·ªÉn th·ªã
          this.guideCanvas.style.width = vw + "px";
          this.guideCanvas.style.height = vh + "px";
          this.guideCanvas.style.position = "absolute";
          this.guideCanvas.style.top = "0";
          this.guideCanvas.style.left = "0";
          this.guideCanvas.style.pointerEvents = "none";

          // match transform v·ªõi video (v√≠ d·ª• scaleX(-1))
          this.guideCanvas.style.transform = this.video.style.transform || "";
          this.guideCanvas.style.transformOrigin = "center center";

          // context scale ƒë·ªÉ v·∫Ω b·∫±ng CSS-pixel coordinates
          this.guideCtx = this.guideCanvas.getContext("2d");
          this.guideCtx.setTransform(ratio, 0, 0, ratio, 0, 0);
        }

        async init() {
          // Video element
          this.video = document.createElement("video");
          this.video.autoplay = true;
          this.video.playsInline = true;
          this.video.muted = true;
          this.video.style.width = "100%";
          this.video.style.height = "100%";
          this.video.style.objectFit = "contain"; // ho·∫∑c "contain" t√πy mu·ªën
          this.video.style.display = "block"; // tr√°nh margin m·∫∑c ƒë·ªãnh
          this.video.style.position = "absolute"; // n·∫øu overlay canvas
          this.video.style.top = "0";
          this.video.style.left = "0";
          this.video.style.transform = "scaleX(1)";
          this.container.innerHTML = "";
          this.container.appendChild(this.video);

          // ensure container positioned so canvas absolute v·ªã tr√≠ ƒë√∫ng
          if (this.container) {
            this.container.style.position =
              this.container.style.position || "relative";
            this.container.innerHTML = "";
            this.container.appendChild(this.video);
          }

          // Camera stream
          this.stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: "user" },
            audio: false
          });
          this.video.srcObject = this.stream;

          // Ch·ªù metadata c√≥ k√≠ch th∆∞·ªõc video
          await new Promise((resolve) => {
            this.video.onloadedmetadata = () => resolve();
          });
          await this.video.play();

          // t·∫°o canvas overlay
          this.guideCanvas = document.createElement("canvas");
          this.guideCanvas.className = "guide-canvas";
          this.container.appendChild(this.guideCanvas);

          // set k√≠ch th∆∞·ªõc & context
          this.updateCanvasSize();

          // optional: c·∫≠p nh·∫≠t khi resize c·ª≠a s·ªï ho·∫∑c container thay ƒë·ªïi
          this._resizeHandler = () => {
            this.updateCanvasSize();
            // redraw h∆∞·ªõng d·∫´n ngay sau resize
            this.drawGuide(this.steps[this.currentStep]);
          };
          window.addEventListener("resize", this._resizeHandler);

          // v·∫Ω h∆∞·ªõng d·∫´n ban ƒë·∫ßu
          this.drawGuide(this.steps[this.currentStep]);
        }

        start() {
          // Recorder
          this.recorder = new MediaRecorder(this.stream, {
            mimeType: "video/webm",
          });
          this.recorder.ondataavailable = (e) => this.chunks.push(e.data);
          this.recorder.onstop = () => this.handleRecordingStop();
          this.recorder.start();

          // Auto-stop sau 15s
          this.stopTimeout = setTimeout(
            () => this.finish(false, "timeout"),
            15000
          );

          // Detect loop
          this.detectLoop();
        }

        async detectLoop() {
          this.detectLoopId = requestAnimationFrame(() => this.detectLoop());

          try {
            const result = await faceapi
              .detectSingleFace(
                this.video,
                new faceapi.TinyFaceDetectorOptions()
              )
              .withFaceLandmarks()
              .withFaceExpressions();

            if (!result) {
              this.clearGuideOverlay();
              return;
            }

            const box = result.detection.box;
            const landmarks = result.landmarks || {};
            const noseArr =
              typeof landmarks.getNose === "function"
                ? landmarks.getNose()
                : [];
            // ch·ªçn ƒëi·ªÉm m≈©i gi·ªØa (robust h∆°n index c·ªë ƒë·ªãnh)
            const nosePoint =
              noseArr && noseArr.length
                ? noseArr[Math.floor(noseArr.length / 2)]
                : { x: box.x + box.width / 2, y: box.y + box.height / 2 };

            const faceNose = { x: nosePoint.x, y: nosePoint.y };
            const guideCenter = {
              x: this.video.videoWidth / 2,
              y: this.video.videoHeight / 2,
            };

            // V·∫Ω overlay (v·∫Ω c·∫£ box v√† ƒëi·ªÉm m≈©i)
            this.drawOverlay(box, nosePoint);

            const step = this.steps[this.currentStep];
            if (this.isStepSatisfied(step, faceNose, guideCenter)) {
              this.stableCount++;
              if (this.stableCount >= this.requiredStableFrames) {
                this.currentStep++;
                this.stableCount = 0;

                if (this.currentStep >= this.steps.length) {
                  console.log("‚úÖ Ho√†n t·∫•t t·∫•t c·∫£ c√°c b∆∞·ªõc quay ƒë·∫ßu");
                  // üëâ ch·ªâ stop recorder, KH√îNG g·ªçi finish ·ªü ƒë√¢y
                  if (this.recorder?.state !== "inactive") {
                    this.recorder.stop();
                  }
                  return;
                }
                console.log(
                  "üëâ Chuy·ªÉn sang b∆∞·ªõc:",
                  this.steps[this.currentStep]
                );
                this.drawGuide(this.steps[this.currentStep]);
                window.faceStepDone?.(step);
              }
            } else {
              this.stableCount = 0;
            }
          } catch (e) {
            console.error("Detect error:", e);
          }
        }

        drawOverlay(box, nosePoint) {
          if (!this.guideCtx || !this.video || !this.guideCanvas) return;
          const ctx = this.guideCtx;
          const ratio = window.devicePixelRatio || 1;
          const cssW = this.guideCanvas.width / ratio;
          const cssH = this.guideCanvas.height / ratio;

          // clear in CSS-pixel coords
          ctx.clearRect(0, 0, cssW, cssH);

          // draw guide first
          this.drawGuide(this.steps[this.currentStep]);

          // intrinsic video size
          const videoIntrinsicW = this.video.videoWidth;
          const videoIntrinsicH = this.video.videoHeight;
          if (!videoIntrinsicW || !videoIntrinsicH) return;

          // scale from intrinsic -> displayed (CSS)
          const scaleX = cssW / videoIntrinsicW;
          const scaleY = cssH / videoIntrinsicH;

          // map and draw box
          const x = box.x * scaleX;
          const y = box.y * scaleY;
          const w = box.width * scaleX;
          const h = box.height * scaleY;

          ctx.strokeStyle = "red";
          ctx.lineWidth = 3;
          ctx.strokeRect(x, y, w, h);

          // draw nose point (if provided)
          if (nosePoint && typeof nosePoint.x === "number") {
            const nx = nosePoint.x * scaleX;
            const ny = nosePoint.y * scaleY;
            ctx.fillStyle = "yellow";
            ctx.beginPath();
            ctx.arc(
              nx,
              ny,
              Math.max(4, Math.min(cssW, cssH) * 0.01),
              0,
              2 * Math.PI
            );
            ctx.fill();
            // optional: small crosshair
            ctx.strokeStyle = "black";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(nx - 6, ny);
            ctx.lineTo(nx + 6, ny);
            ctx.moveTo(nx, ny - 6);
            ctx.lineTo(nx, ny + 6);
            ctx.stroke();
          }
        }

        clearGuideOverlay() {
          if (!this.guideCtx) return;
          this.guideCtx.clearRect(
            0,
            0,
            this.guideCanvas.width,
            this.guideCanvas.height
          );
          // V·∫Ω l·∫°i v√≤ng tr√≤n h∆∞·ªõng d·∫´n ƒë·ªÉ user v·∫´n th·∫•y khung
          this.drawGuide(this.steps[this.currentStep]);
        }

        isStepSatisfied(step, face, guide) {
          const w = this.video?.videoWidth || 640;
          const h = this.video?.videoHeight || 480;
          const offsetX = Math.max(30, w * 0.12); // min 30px or 12% width
          const offsetY = Math.max(30, h * 0.12); // min 30px or 12% height

          const dx = face.x - guide.x;
          const dy = face.y - guide.y;

          switch (step) {
            case "center":
              return Math.abs(dx) < offsetX && Math.abs(dy) < offsetY;
            case "left":
              return dx < -offsetX;
            case "right":
              return dx > offsetX;
            case "up":
              return dy < -offsetY;
            case "down":
              return dy > offsetY;
            default:
              return false;
          }
        }

        drawGuide(step) {
          if (!this.guideCtx || !this.guideCanvas) return;
          const ctx = this.guideCtx;
          const ratio = window.devicePixelRatio || 1;
          const cssW = this.guideCanvas.width / ratio;
          const cssH = this.guideCanvas.height / ratio;
          // nh·∫π nh√†ng clear (drawOverlay c≈©ng clear tr∆∞·ªõc khi g·ªçi)
          ctx.clearRect(0, 0, cssW, cssH);
          ctx.strokeStyle = "lime";
          ctx.lineWidth = 4;
          const cx = cssW / 2;
          const cy = cssH / 2;
          const r = Math.min(cssW, cssH) * 0.2; // responsive radius
          ctx.beginPath();
          ctx.arc(cx, cy, r, 0, 2 * Math.PI);
          ctx.stroke();
          ctx.fillStyle = "lime";
          ctx.font = Math.max(14, Math.round(cssW * 0.02)) + "px Arial";
          ctx.textAlign = "center";
          ctx.fillText("Look " + step, cx, cy - r - 12);
        }

        handleRecordingStop() {
          if (this.chunks.length === 0) {
            this.finish(false, "no_chunks");
            return;
          }

          const blob = new Blob(this.chunks, { type: "video/webm" });
          const reader = new FileReader();
          reader.onloadend = () => {
            const base64Video = reader.result.split(",")[1];
            this.finish(true, null, base64Video);
          };
          reader.readAsDataURL(blob);
        }

        finish(success, error, videoBase64 = null) {
          if (this.completeCalled) return;
          this.completeCalled = true;

          clearTimeout(this.stopTimeout);
          cancelAnimationFrame(this.detectLoopId);

          if (this.recorder?.state !== "inactive") {
            this.recorder.stop();
          }

          this.stream?.getTracks().forEach((track) => track.stop());

          window.faceRegisterComplete?.(success, videoBase64);
        }

        dispose() {
          this.finish(false, "disposed");
          this.container.innerHTML = "";
        }
      }

      // G·∫Øn v√†o window ƒë·ªÉ Flutter g·ªçi
      window.faceRegisterStart = async function (containerId) {
        faceRegisterController = new FaceRegisterController(containerId);
        await faceRegisterController.init();
        faceRegisterController.start();
      };

      window.faceRegisterDispose = function () {
        if (faceRegisterController) {
          faceRegisterController.dispose();
          faceRegisterController = null;
        }
      };

      // ========

      window.loadFaceModels = loadFaceModels;
      window.detectFaceFromBase64 = detectFaceFromBase64;
    </script>
  </head>
  <body>
    <script src="flutter_bootstrap.js" async></script>
  </body>
</html>
